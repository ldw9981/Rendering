vs.1.0              // version instruction

m4x4 oPos, v0, c0   // transform vertices by view/projection matrix

mov  oT0.xy, v2
mov  oT1.xy, v2

// v0 - pozicia vrchola
// v1 - normalovy vektor
// v2 - texture coordination

// c0-c3 contains composite transform matrix
// c5   0.5,-0.5,0.5,0.5
// c6   pozicia kamery v suradniciach objektu
// c7   -2,-2,-2,-2
// c8   0,0,1,0


// inline vec ReflectedRay( const vec &in, const vec &n)	// in from eye to vertex
// return (in - 2.f*n*DOT3( in, n));

add  r0, v0, -c6		// r0 = in = vertex - eye

// normalize vector in r0
dp3  r0.w, r0, r0		// r0.w = |r0|^2
rsq  r0.w, r0.w			// r0.w = 1/sqrt(r0.w) = 1/|r0|
mul  r0.xyz, r0, r0.w	// r0 - normalized in vector

// DOT3( in, n)
dp3  r1, r0, v1		// r0 = in, v1 = n

// n*DOT3( in, n)
mul  r1, r1, v1		// v1 = n

// in - 2.f*n*DOT3( in, n) = f = r1
mad  r1, r1, c7, r0		// r1 = r1*c7+r0

// r1 = f
// m = 2.f * sqrt( fx^2 + fy^2 + (fz+1)^2) )

// r2 = (fx,fy,fz+1)
add  r2, r1, c8		// c8 = 0,0,1,0

// r2 = fx^2 + fy^2 + (fz+1)^2
dp3  r2, r2, r2

// r2 = 1.f / sqrt( fx^2 + fy^2 + (fz+1)^2) )
rsq  r2, r2

// r2 = 1.f / 2.f * sqrt( fx^2 + fy^2 + (fz+1)^2) )
// r2.y is negate because DX use reverse texture coordination y as OpenGL ( and us formula )
mul  r2, r2, c5		// c5   0.5,-0.5,0.5,0.5

// r2 = 1.f/m

// s = fx/m + 0.5f
// t = fy/m + 0.5f
// for DX, tdx = -t = fy/(-m.y) - 0.5 = fy*r2.y + c5.y

// s = fx*r2.x + c5.x
// s = fy*r2.y + c5.y

mad  oT2.xy, r1, r2, c5
